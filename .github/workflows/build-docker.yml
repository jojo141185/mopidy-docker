name: Build multi-arch docker images and publish on DockerHub and GHCR

# 1. Controls when the action will run
on:
  # -> Manually from the Actions tab
  workflow_dispatch:
    inputs:
      logLevel:
        type: choice
        description: Log level
        required: false
        default: info
        options:
          - info
          - debug
      image:
        type: choice
        description: 'Image tag to build'
        required: false
        default: all
        options:
          - all
          - latest
          - develop
          - release
      platform:
        type: choice
        description: 'Platform to build'
        required: false
        default: all
        options:
          - all
          - linux/amd64
          - linux/arm64
          - linux/arm/v7

  # -> On push to main/develop branches or version tags
  push:
    branches:
      - main
      - develop
    tags:
      - 'v*'
    paths-ignore:
      - '**.md'
      #- '.github/workflows/**'
      - 'docs/**'

  # -> On pull requests targeting the main branch
  pull_request:
    branches:
      - main
    paths-ignore:
      - '**.md'
      #- '.github/workflows/**'
      - 'docs/**'

  # -> On a weekly schedule
  schedule:
    - cron: '0 2 * * 0' # every Sunday at 2am UTC

# 2. Environment variables available to all jobs
env:
  DOCKERHUB_SLUG: ${{ secrets.DOCKERHUB_USERNAME }}/mopidy
  GHCR_SLUG: ghcr.io/${{ github.repository_owner }}/mopidy

# 3. Permissions for the GITHUB_TOKEN
permissions:
  contents: read
  packages: write # Required to publish packages to GHCR

# 4. A workflow run is made up of one or more jobs
jobs:
  # Job to define the build matrix for all subsequent jobs. This is the single source of truth.
  prepare_build:
    name: Prepare Build Matrix
    runs-on: ubuntu-latest
    outputs:
      images: ${{ steps.set-matrix.outputs.images }}
      platforms: ${{ steps.set-matrix.outputs.platforms }}
    steps:
      - id: set-matrix
        run: |
          # Define the full lists of images and platforms
          ALL_IMAGES='["latest", "develop", "release"]'
          ALL_PLATFORMS='["linux/amd64", "linux/arm64", "linux/arm/v7"]'

          # Process the 'image' input from the manual trigger
          if [ -z "${{ github.event.inputs.image }}" ] || [ "${{ github.event.inputs.image }}" == "all" ]; then
            echo "images=${ALL_IMAGES}" >> $GITHUB_OUTPUT
          else
            SINGLE_IMAGE="[\"${{ github.event.inputs.image }}\"]"
            echo "images=${SINGLE_IMAGE}" >> $GITHUB_OUTPUT
          fi

          # Process the 'platform' input from the manual trigger
          if [ -z "${{ github.event.inputs.platform }}" ] || [ "${{ github.event.inputs.platform }}" == "all" ]; then
            echo "platforms=${ALL_PLATFORMS}" >> $GITHUB_OUTPUT
          else
            SINGLE_PLATFORM="[\"${{ github.event.inputs.platform }}\"]"
            echo "platforms=${SINGLE_PLATFORM}" >> $GITHUB_OUTPUT
          fi

  # Job to build the docker images for each platform on a dedicated runner using the matrix strategy
  build:
    name: Build
    needs: prepare_build
    # The type of runner that the job will run on
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      # List of platforms and images on which the job will be run in parallel.
      # The lists are provided by the 'prepare_build' job.
      matrix:
        platform: ${{ fromJson(needs.prepare_build.outputs.platforms) }}
        image: ${{ fromJson(needs.prepare_build.outputs.images) }}

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Store current platform from matrix as variable $PLATFORM_PAIR (with "/" replaced by "-")
      - name: Prepare
        run: |
          platform=${{ matrix.platform }}
          echo "PLATFORM_PAIR=${platform//\//-}" >> $GITHUB_ENV

      # Github action to provide runner with OS information
      - name: Get GitHub Actions runner OS information
        uses: kenchan0130/actions-system-info@master
        id: system-info

      - name: Output System information
        run: |
          OUTPUTS=(
            "CPU Core: ${{ steps.system-info.outputs.cpu-core }}"
            "CPU Model: ${{ steps.system-info.outputs.cpu-model }}"
            "Hostname: ${{ steps.system-info.outputs.hostname }}"
            "Kernel release: ${{ steps.system-info.outputs.kernel-release }}"
            "Kernel version: ${{ steps.system-info.outputs.kernel-version }}"
            "Name: ${{ steps.system-info.outputs.name }}"
            "Platform: ${{ steps.system-info.outputs.platform }}"
            "Release: ${{ steps.system-info.outputs.release }}"
            "Total memory bytes: ${{ steps.system-info.outputs.totalmem }}"
          )

          for OUTPUT in "${OUTPUTS[@]}";do
            echo "${OUTPUT}"
          done

          echo "Disk Space:"
          df -h

      # Free up disk space by removing unused toolchains to prevent "No space left on device"
      - name: Free Disk Space (Ubuntu)
        if: matrix.platform == 'linux/arm/v7'
        uses: jlumbroso/free-disk-space@main
        with:
          # this might remove tools that are actually needed,
          # if set to "true" but frees about 6 GB
          tool-cache: false

          # all of these default to true, but feel free to set to
          # "false" if necessary for your workflow
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true

          # Set to false. Let the 'docker-on-tmpfs' action manage its own swapfile.
          # This prevents the "swapoff failed: No such file or directory" error.
          swap-storage: false

      # Github Action to get branch or tag information without the /ref/* prefix
      - name: Get branch names
        id: branch-name
        uses: tj-actions/branch-names@v6

      # Github Action to check-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - name: Checkout
        uses: actions/checkout@v4.1.1

      # GitHub Action to install QEMU static binaries (optional for more platform options in buildx)
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      # GitHub Action to set up Docker Buildx.
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          buildkitd-flags: ${{ github.event.inputs.logLevel == 'debug' && '--debug' }}
      
      # Hack to fix Errors on arm/v7 and linux/386
      # Work around for qemu bug on 32bit systems caused during rust compilation (https://github.com/JonasAlfredsson/docker-on-tmpfs?tab=readme-ov-file)
      # - "Value too large for defined data type;" https://github.com/crazy-max/ghaction-docker-buildx/issues/172
      # - "object not found - no match for id (SOME_HASH)" on git update
      - name: Run Docker on tmpfs
        if: matrix.platform == 'linux/arm/v7' || matrix.platform == 'linux/i386'
        uses: JonasAlfredsson/docker-on-tmpfs@v1
        with:
          tmpfs_size: 10
          swap_size: 10
          swap_location: '/mnt/swapfile'

      # GitHub Action to extract metadata (tags, labels) for Docker.
      - name: Docker meta
        id: docker_meta
        uses: docker/metadata-action@v5
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          images: |
            ${{ env.DOCKERHUB_SLUG }}
            ${{ env.GHCR_SLUG }}
          labels: |
            org.opencontainers.image.title=${{ env.DOCKERHUB_SLUG }}
            org.opencontainers.image.description='Mopidy music server with Iris Web-UI, Spotify support and many other extensions.'
            org.opencontainers.image.vendor=${{ secrets.DOCKERHUB_USERNAME }}

      # GitHub Action to login to DockerHub.
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # GitHub Action to login to GitHub Container Registry.
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # --- This step is only for single item manual runs --- #
      # Build and push with a specific tag for manual runs that don't build everything.
      - name: Build and push with specific tag (for single item manual run)
        if: github.event_name == 'workflow_dispatch' && (github.event.inputs.platform != 'all' || github.event.inputs.image != 'all')
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: ${{ matrix.platform }}
          provenance: false
          labels: ${{ steps.docker_meta.outputs.labels }}
          push: true
          tags: |
            ${{ env.DOCKERHUB_SLUG }}:${{ matrix.image }}-${{ env.PLATFORM_PAIR }}
            ${{ env.GHCR_SLUG }}:${{ matrix.image }}-${{ env.PLATFORM_PAIR }}
          build-args: |
            IMG_VERSION=${{ matrix.image }}
            BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
            VCS_REF=$(echo $GITHUB_SHA | cut -c1-8)

      # --- Next steps only for multi-arch/multi-image runs --- #
      # Build and push by digest for multi-item runs
      - name: Build and push by digest (for multi-item run)
        id: docker_build_digest
        if: github.event_name != 'workflow_dispatch' || (github.event.inputs.platform == 'all' && github.event.inputs.image == 'all')
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: ${{ matrix.platform }}
          provenance: false
          labels: ${{ steps.docker_meta.outputs.labels }}
          tags: |
            ${{ env.DOCKERHUB_SLUG }}
            ${{ env.GHCR_SLUG }}
          #cache-from: type=gha,scope=${{ github.repository }}-${{ github.ref_name }}-${{ matrix.platform }}-${{ matrix.image }}
          #cache-to: type=gha,mode=max,scope=${{ github.repository }}-${{ github.ref_name }}-${{ matrix.platform }}-${{ matrix.image }}
          outputs: type=image,name=${{ env.DOCKERHUB_SLUG }},name=${{ env.GHCR_SLUG }},push-by-digest=true,name-canonical=true,push=true
          build-args: |
            IMG_VERSION=${{ matrix.image }}
            BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
            VCS_REF=$(echo $GITHUB_SHA | cut -c1-8)

      # Export digest and store in GitHub artefact storage for later use in other jobs
      - name: Export digest
        if: github.event_name != 'workflow_dispatch' || (github.event.inputs.platform == 'all' && github.event.inputs.image == 'all')
        run: |
          mkdir -p /tmp/digests/${{ matrix.image }}
          digest="${{ steps.docker_build_digest.outputs.digest }}"
          touch "/tmp/digests/${{ matrix.image }}/${digest#sha256:}"

      # Upload digest artifact
      - name: Upload digest
        if: github.event_name != 'workflow_dispatch' || (github.event.inputs.platform == 'all' && github.event.inputs.image == 'all')
        uses: actions/upload-artifact@v4
        with:
          name: digests-${{ matrix.image }}-${{ env.PLATFORM_PAIR }}
          path: /tmp/digests/${{ matrix.image }}/*
          if-no-files-found: error
          retention-days: 1

      - name: Clear digest
        if: github.event_name != 'workflow_dispatch' || (github.event.inputs.platform == 'all' && github.event.inputs.image == 'all')
        run: |
          rm -rf /tmp/digests/${{ matrix.image }}

  # Job to merge the multi-arch images into a single manifest
  merge:
    # Only run this job for full multi-arch and multi-image builds
    if: |
      github.event_name != 'pull_request' &&
      (
        github.event_name != 'workflow_dispatch' ||
        (github.event.inputs.platform == 'all' && github.event.inputs.image == 'all')
      )
    name: Merge Docker manifests
    needs: [build, prepare_build]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        image: ${{ fromJson(needs.prepare_build.outputs.images) }}
    steps:
      # Download all digest artifacts
      - name: Download digests
        uses: actions/download-artifact@v4
        with:
          path: /tmp/digests/${{ matrix.image }}
          pattern: digests-${{ matrix.image }}-*
          merge-multiple: true

      # Set up Docker Buildx
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # GitHub Action to extract metadata (final tags) for Docker.
      - name: Docker meta
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ env.DOCKERHUB_SLUG }}
            ${{ env.GHCR_SLUG }}
          tags: |
            type=raw,value=${{ matrix.image }},enable=${{ github.ref_name == github.event.repository.default_branch }}
            type=raw,value=dev_${{ matrix.image }},enable=${{ github.ref == format('refs/heads/{0}', 'develop') }}
            type=raw,value=test_${{ matrix.image }},enable=${{ github.ref_name != github.event.repository.default_branch && github.ref != format('refs/heads/{0}', 'develop') }}

      # Login to Docker Hub
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # Login to GitHub Container Registry
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Create and push the multi-arch manifest
      - name: Create manifest list and push
        working-directory: /tmp/digests/${{ matrix.image }}
        run: |
          docker buildx imagetools create $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< '${{ steps.meta.outputs.json }}') \
            $(printf '${{ env.DOCKERHUB_SLUG }}@sha256:%s ' *)

      # Inspect the final image on Docker Hub and GHCR
      - name: Inspect final images
        run: |
          docker buildx imagetools inspect ${{ fromJson(steps.meta.outputs.json).tags[0] }}
          docker buildx imagetools inspect ${{ fromJson(steps.meta.outputs.json).tags[1] }}

  # Job to clean up single-arch tags from Docker Hub
  cleanup_dockerhub_tags:
    name: Cleanup Docker Hub Tags
    needs: [merge, prepare_build]
    runs-on: ubuntu-latest
    # Only run this job after a successful full build
    if: success() && (github.event_name != 'workflow_dispatch' || (github.event.inputs.platform == 'all' && github.event.inputs.image == 'all'))
    steps:
      # This step installs dependencies (jq), downloads hub-tool, and logs in ONCE.
      - name: Install dependencies and Login to Docker Hub
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          VERSION=v0.4.6
          curl -sL "https://github.com/docker/hub-tool/releases/download/${VERSION}/hub-tool-linux-amd64.tar.gz" -o hub-tool.tar.gz
          tar --strip-components=1 -xzf ./hub-tool.tar.gz && ./hub-tool --version
          HUB_TOKEN=$(curl -s -H "Content-Type: application/json" -X POST -d '{"username": "${{ secrets.DOCKERHUB_USERNAME }}", "password": "${{ secrets.DOCKERHUB_TOKEN }}"}' https://hub.docker.com/v2/users/login/ | jq -r .token)
          USERNAME_B64="$(printf '%s:' "${{ secrets.DOCKERHUB_USERNAME }}" | base64 -w0)"
          USER_PASS_B64="$(printf '%s:%s' "${{ secrets.DOCKERHUB_USERNAME }}" "${{ secrets.DOCKERHUB_TOKEN }}" | base64 -w0)"
          mkdir -p ~/.docker/ && printf '{"auths": {"hub-tool": {"auth": "%s"}, "hub-tool-refresh-token": {"auth": "%s"}, "hub-tool-token": { "auth": "%s", "identitytoken": "%s"}}}' "$USER_PASS_B64" "$USERNAME_B64" "$USERNAME_B64" "$HUB_TOKEN" > ~/.docker/config.json

      # This step uses the lists from 'prepare_build' to loop through all tags and remove them from Docker Hub.
      - name: Remove all tags from Docker Hub
        run: |
          mapfile -t images < <(echo '${{ needs.prepare_build.outputs.images }}' | jq -r '.[]')
          mapfile -t platforms < <(echo '${{ needs.prepare_build.outputs.platforms }}' | jq -r '.[]')
          for image in "${images[@]}"; do
            for platform in "${platforms[@]}"; do
              platform_slug=${platform//\//-}
              tag_to_delete="${image}-${platform_slug}"
              echo "Attempting to delete tag from Docker Hub: ${{ env.DOCKERHUB_SLUG }}:${tag_to_delete}"
              ./hub-tool tag rm --force ${{ env.DOCKERHUB_SLUG }}:${tag_to_delete} || true
            done
          done

      # Always run this step to ensure credentials are cleaned up.
      - name: Logout from Docker Hub
        if: always()
        run: rm -f ~/.docker/config.json

  # Job to clean up single-arch tags from GitHub Container Registry
  cleanup_ghcr_tags:
    name: Cleanup GHCR Tags
    needs: [merge, prepare_build]
    runs-on: ubuntu-latest
    # Only run this job after a successful full build
    if: success() && (github.event_name != 'workflow_dispatch' || (github.event.inputs.platform == 'all' && github.event.inputs.image == 'all'))
    strategy:
      fail-fast: false
      # This job-level matrix is the correct way to run the delete action for each combination
      matrix:
        image: ${{ fromJson(needs.prepare_build.outputs.images) }}
        platform: ${{ fromJson(needs.prepare_build.outputs.platforms) }}
    steps:
      # This step creates the tag name using shell substitution, which is reliable and avoids linter issues.
      - name: Construct tag to delete
        id: construct
        run: |
          platform=${{ matrix.platform }}
          platform_slug=${platform//\//-}
          echo "tag_to_delete=${{ matrix.image }}-${platform_slug}" >> $GITHUB_OUTPUT

      - name: Remove tag from GitHub Container Registry
        uses: bots-house/ghcr-delete-image-action@v1.1.0
        with:
          owner: ${{ github.repository_owner }}
          name: mopidy
          token: ${{ secrets.WORKFLOW_PAT }}
          tag: ${{ steps.construct.outputs.tag_to_delete }}
        continue-on-error: true